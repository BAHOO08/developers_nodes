# GDB

Запуск

```bash
run
```

Gdb пораждает процессы, и infefior .. (process ...) - означает пораждённый процесс
 для перенаправления ввода можно прописать
 ```bash
 (gdb) run < 1.dat
```
где 1.dat - файл, который  поеренаправляем на ввод

| полный синтаксис | сокращение | описание                                             |
| ---------------- | ---------- | ---------------------------------------------------- |
| run              | r          | запуск программы                                     |
| continue         | c          | продолжить                                           |
| break            | b          | установить брейкпоинт                                |
| print            | p          |                                                      |
| explore          | e          |                                                      |
| next             | n          |                                                      |
| stap             | s          |                                                      |
| delete           | d          |                                                      |
| start            |            | поставить временный брейкпоинт на main и сделать run |
| finish           |            | Завершить текущую функцию                            |
|                  | x          |                                                      |
| set              |            | запись значения, например set $i=0                   |
| dysplay          |            | вывод чегото когда мы доходим до брейкпоинта         |
| bt               |            | бектрейс                                             |
| frame            |            |                                                      |

Получить инфу по брейк поинтам
```bash
info breakpionts
```

Удаление брейкпоинта 1
```bash
delete 1
```

Временный брейкпоинт на main
```bash
tbreak main
```
Он удалится при его достижении



gdb поддерживает нативно 
- cli - common line interface интерфейс gdb
- tui - text user interface 
Для перехода в tui надо прописать
```bash
tui enable
```
Для выхода
```bash
tui desable
```
Сделать активным командное окно
cntrl + x + o
Обновить экран
ctrl + l

Можно задавать код в строку для дебага, например
```bash
while($i < $end)
p a[$i]
set $i = $i + 1
end
```
Вывести массив можно и проще
```bash
p *a@5
```
где 5 - количество элементов
Для остановки брейкпоинта по условию достаточно прописать
```bash
b 50 (создался брейкпоинт допустим 1)
condition 2 (a[j] == 0)
```
Когда мы хотим выводить что-то, когда доходим до брейкпоинта можем ввести
```bash
display *a@5
```
```bash
set pagination off/on
```
## Отличие next и step
next - следующая в текущей функции.
step - следующая исполняемая строчка. 
Например
```c++
void foo()
{
	int i = 2; // будем тут после step
}
int main()
{
	int a; 
	foo(); // сейчас стоим тут
	return 0; // будем тут после next
}
```
gui поддерживается сторонними приложениями, например
- ddd - gui над gdb
Просто энтер - повторение предыдущей команды
## print
параметры print выводятся через слэш
Например для хексового представления
```bash
p/x n
```
по умолчанию чар указатель пытается вызвать в виде строки. Для отображения данных можно использовать explore(x)
Можно производить арифметические операции с учётом типов
```bash
p n * n
p (long) n * n
```
## explore
Если мы хотим выдать 10 ячеек в байтовом формате
```bash
x/10b ptr
```

#cpp 